## # `Basics` -

- Plaintext is unencrypted data and ciphertext is encrypted data.
- An algorithm takes plaintext as input and performs rounds (i.e., iterations) of operations to produce ciphertext.
- A key is combined with an algorithm to scramble plaintext into ciphertext. The key should be kept secret.
- A nonce:
	- A “number used once”, and it is used by algorithms to add variation so that a message encrypted with the same key does not produce the same ciphertext. This prevents a category of attacks known as “replay attacks”, where an attacker could reuse encryption communications or extract some meaning from it.
	- It is not necessarily random, but it should only be used once.
- An Initialization Vector is like a nonce, but it must be random. An Initialization Vector (IV) is a random value that provided as input to an encryption algorithm with the key. The IV must be random, but it does not need to be a secret.

## # `Symmetric-Key Encryption` -

- Symmetric-Key Encryption Algorithms Use the Same Key to Encrypt and Decrypt Data
- The key is referred to as a “shared secret”.
- Symmetric encryption algorithms are relatively fast and suitable for encrypting large volumes of data.
- In ransomware, symmetric encryption algorithms are used to encrypt files.

Symmetric encryption is relatively straightforward, but it requires that ==two communicating parties have the same key==. Sharing this key in a secure manner can be inconvenient and difficult to accomplish. If an attacker were to intercept the exchange of keys, they would be able to decipher messages between the two parties.

## # `Asymmetric-Key Encryption` -

- Also referred to as ==public-key cryptography==, this approach includes two keys: a ==public key that is shared==, and a ==private key that is kept secret==.
- Data encrypted with the public key can only be decrypted with the corresponding private key.
- Example applications: RSA, Diffie-Hellman, and Elliptic-curve crypto.
- Relative to symmetric encryption, asymmetric encryption is slow and best suited for encrypting small amount of data.
- In ransomware, asymmetric encryption algorithms are often used to protect symmetric keys on the target machine.

## # `Microsoft CryptoAPI` -

- The Microsoft CryptoAPI Includes Functions for Encryption.
- The CryptoAPI is often used to perform encryption using the AES and/or RSA algorithms.
- The CryptoAPI may be used to encrypt file contents, but this task is often performed by additional code in the executable.
- Malware authors often resolve these APIs at runtime to hinder detection and avoid including these functions in the IAT (e.g., API hashing).

####  ## <mark style="background: #3D7EFFA6;">CryptAcquireContext</mark> -

- Malware That Performs Encryption via the MS CryptoAPI Typically Calls CryptAcquireContext First.
- ==CryptAcquireContext is the first API called when the Microsoft CryptoAPI is used for encryption==. It returns a handle to a Cryptographic Service Provider (CSP). A CSP is a software module (i.e., a DLL) that provides the desired encryption functionality for a supported algorithm. The handle returned by CryptAcquireContext is used in future calls to CryptoAPI functions to perform encryption and/or decryption.
- CryptAcquireContext connects an application with a Cryptographic Service Provider (CSP), which is a module that contains the desired encryption and/or decryption functionality for an algorithm.
- Syntax -

```c++
BOOL CryptAcquireContextA(
  [out] HCRYPTPROV *phProv,
  [in]  LPCSTR     szContainer,
  [in]  LPCSTR     szProvider,
  [in]  DWORD      dwProvType,
  [in]  DWORD      dwFlags
);
```

CryptAcquireContext has five arguments :

1. <mark style="background: #FFB86CA6;">*phProv</mark> : Address where the returned CSP handle will be located.
2. <mark style="background: #D2B3FFA6;">szContainer</mark> : Pointer to a key container name (typically NULL) and only used if the relevant keys are persistent on the system.
3. <mark style="background: #E632B3A6;">szProvider</mark> : Pointer to the name of the CSP, including the algorithm(s).
4. <mark style="background: #07E997A6;">dwProvType</mark> : Symbolic constant that specifies the provider type.
5. <mark style="background: #FFB86CA6;">dwFlags</mark> : Specifies an optional value.

[MSDN](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta)

#### ## <mark style="background: #3D7EFFA6;">CryptImportKey</mark> -

- CryptImportKey Is Often Used to Import an Embedded Key
- CryptImportKey is a function in the Microsoft CryptoAPI that imports a cryptographic key into a key container.
- Syntax -

```c++
BOOL CryptImportKey(
  [in]  HCRYPTPROV hProv,
  [in]  const BYTE *pbData,
  [in]  DWORD      dwDataLen,
  [in]  HCRYPTKEY  hPubKey,
  [in]  DWORD      dwFlags,
  [out] HCRYPTKEY  *phKey
);
```

CryptImportKey has six arguments :

1. <mark style="background: #FFB86CA6;">hProv</mark> : Handle to the key returned by CryptAcquireContext.
2. <mark style="background: #D2B3FFA6;">*pbData</mark> : Pointer to a BLOBHEADER structure for a key. A pointer to the buffer that contains the key BLOB to be imported.
3. <mark style="background: #E632B3A6;">dwDataLen</mark> : Length of the key BLOB, in bytes.
4. <mark style="background: #07E997A6;">hPubKey</mark> : Handle to a key that decrypts key BLOB (NULL if not encrypted).
5. <mark style="background: #FFB86CA6;">dwFlags</mark> : A set of flags that modifies the behavior of the function.. ==If the key to import is a public key, this is NULL==.
6. <mark style="background: #D2B3FFA6;">*phKey</mark> : Pointer to a handle to the imported key (upon return).

Return Value:

If the function succeeds, the return value is nonzero (TRUE).

If the function fails, the return value is zero (FALSE). To retrieve extended error information, call GetLastError.

[MSDN](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptimportkey)

#### ## <mark style="background: #3D7EFFA6;">BlobHeader (aka PUBLICKEYSTRUC)</mark> -

- The BlobHeader (A.K.A. PUBLICKEYSTRUC) Structure ==Specifies the Key Type and Algorithm==.
- PUBLICKEYSTRUC is a structure used in the Microsoft CryptoAPI to describe the format of public and private keys.
- Syntax -

```c++
typedef struct _PUBLICKEYSTRUC {
  BYTE   bType;
  BYTE   bVersion;
  WORD   reserved;
  ALG_ID aiKeyAlg;
} BLOBHEADER, PUBLICKEYSTRUC;
```

1. <mark style="background: #FFB86CA6;">bType</mark> specifies the BLOB type and includes:
	• `PLAINTEXTKEYBLOB` : 0x8 (symmetric key)
	• `PRIVATEKEYBLOB`: 0x7
	• `PUBLICKEYBLOB` : 0x6

2. <mark style="background: #D2B3FFA6;">bVersion</mark> : The version number of the key blob format. The current version number is `0x02`.
3. <mark style="background: #E632B3A6;">reserved</mark> : This field is reserved for future use and must be set to `0`.
4. <mark style="background: #07E997A6;">aiKeyAlg</mark> : ==The algorithm ID of the key==. This can be any valid algorithm identifier that is supported by the CryptoAPI. For example, `CALG_RSA_KEYX` indicates that the key is an RSA key used for key exchange.

[MSDN PublicKeyStruct](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/ns-wincrypt-publickeystruc)

[MSDN alg-id](https://learn.microsoft.com/en-us/windows/win32/seccrypto/alg-id)

#### ## <mark style="background: #3D7EFFA6;">CryptGenRandom</mark> -

- CryptGenRandom Is Often Used to Generate Random Bytes for a Key, Nonce, or Initialization Vector (IV).
- Syntax -

```c++
BOOL CryptGenRandom(
  [in]      HCRYPTPROV hProv,
  [in]      DWORD      dwLen,
  [in, out] BYTE       *pbBuffer
);
```

This API takes three arguments :

1. <mark style="background: #FFB86CA6;">hProv</mark> : Handle to a CSP returned by an earlier call to CryptAcquireContext.
2. <mark style="background: #D2B3FFA6;">dwLen</mark> : The number of bytes of random data to generate.
3. <mark style="background: #E632B3A6;">pbBuffer</mark> : Address of the buffer where random bytes will be placed.

The function returns a boolean value that indicates whether the operation was successful or not. If the function succeeds, the buffer pointed to by `pbBuffer` will be filled with the specified number of random bytes.

[MSDN CryptGenRandom](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom)

- The ==number of bytes requested can provide insight into the encryption algorithm, mode of encryption, and purpose of the data==.
- Other APIs used for byte generation include GetTickCount, QueryPerformanceCounter, and RtlGenRandom (SystemFunction036), rand, and srand.

#### ## <mark style="background: #3D7EFFA6;">CryptGenKey</mark> -

- CryptGenKey is a function in the Microsoft CryptoAPI that ==generates a random session key or a public/private key pair==.
- Syntax -

```c++
BOOL CryptGenKey(
  [in]  HCRYPTPROV hProv,
  [in]  ALG_ID     Algid,
  [in]  DWORD      dwFlags,
  [out] HCRYPTKEY  *phKey
);
```

1. <mark style="background: #FFB86CA6;">hProv</mark> : Handle to a CSP returned by an earlier call to CryptAcquireContext.
2. <mark style="background: #D2B3FFA6;">Algid</mark> : ==Identifies the specific symmetric key algorithm or requests a key pair==.
	• **CALG_AES_256**: 0x00006610 (generate AES 256-bit key).
	• **AT_KEYEXCHANGE**: 0x00000001 (generate RSA public/private key pair).
	• **CALG_RSA_KEYX**: 0x0000a400 (generate RSA public/private key pair).
3. <mark style="background: #E632B3A6;">dwFlags</mark> : Specifies the key type. This 32-bit value specifies the type of key generated. ==The upper 16 bits specifies the size of the key==. For example, if the 32-bit value is 0x08000001, the upper 16 bits are 0x0800, which indicates a key size of 2048. The lower 16 bits typically refers to a sub-id that depends upon the type of algorithm. In the case of RSA, if the lower 16 bits are 0x0001, this indicates ALG_SID_RSA_PKCS and refers to generating a public/private key pair.
4. <mark style="background: #07E997A6;">*phKey</mark> : Location of handle to the generated key.

The function returns `TRUE` on success and `FALSE` on failure.

After the key is generated, it can be exported using the `CryptExportKey` function, or used directly by other CryptoAPI functions that require a key handle, such as `CryptEncrypt` and `CryptDecrypt`.

[MSDN Cryptgenkey](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenkey?redirectedfrom=MSDN)

#### ## <mark style="background: #3D7EFFA6;">CryptSetKeyParam</mark> -

- CryptSetKeyParam May Be ==Called to Alter Aspects of a Key’s Operation, Including the Encryption Mode==.
- When CryptGenKey is used to generate a symmetric key, the default encryption mode is cipher block chaining (CBC).
- Synatx -

```c++
BOOL CryptSetKeyParam(
  [in] HCRYPTKEY  hKey,
  [in] DWORD      dwParam,
  [in] const BYTE *pbData,
  [in] DWORD      dwFlags
);
```

1. <mark style="background: #FFB86CA6;">hKey</mark> : A handle to a symmetric or asymmetric key.
2. <mark style="background: #D2B3FFA6;">dwParam</mark> : Specifies the value to update (e.g., IV, cipher operation).
3. <mark style="background: #E632B3A6;">*pbData</mark> : Pointer to a buffer that contains the value to set.
4. <mark style="background: #07E997A6;">dwFlags</mark> : A set of flags that modify the behavior of the function. This can be set to zero for most applications.

[MSDN Cryptsetkeyparam](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptsetkeyparam)

#### ## <mark style="background: #3D7EFFA6;">CryptExportKey</mark> -

- CryptExportKey Exports a Key Generated by CryptGenKey
- Synatx -

```c++
BOOL CryptExportKey(
  [in]      HCRYPTKEY hKey,
  [in]      HCRYPTKEY hExpKey,
  [in]      DWORD     dwBlobType,
  [in]      DWORD     dwFlags,
  [out]     BYTE      *pbData,
  [in, out] DWORD     *pdwDataLen
);
```

1. <mark style="background: #FFB86CA6;">hKey</mark> : Handle to the key for export. This handle is located at the address specified by the \*phKey argument passed to CryptGenKey.
2. <mark style="background: #D2B3FFA6;">hExpKey</mark> : Specifies a key to encrypt a private key; unused for a public key.
3. <mark style="background: #E632B3A6;">dwBlobType</mark> : Type of key to export: PUBLICKEYBLOB (0x6) is common. This can be one of the following values: `PUBLICKEYBLOB`, `PRIVATEKEYBLOB`, `PLAINTEXTKEYBLOB`, `SIMPLEBLOB`, `CRYPTPROTECTMEMORY_BLOB`, `CRYPTPRIVATEKEYINFO`, or `OPAQUEKEYBLOB`.
4. <mark style="background: #07E997A6;">dwFlags</mark> : Typically, NULL.
5. <mark style="background: #FFB86CA6;">*pbData</mark> : Pointer to the buffer that receives exported key BLOB data.
6. <mark style="background: #D2B3FFA6;">*pdwDataLen</mark> : Size of the buffer pointed to byte *pbData.

[MSDN Cryptexportkey](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptexportkey)

If CryptGenKey is used to generate a key, CryptExportKey is often called soon thereafter to access the key. This is because CryptGenKey provides a handle to the key, but not the key itself.

#### ## <mark style="background: #3D7EFFA6;">CryptEncrypt</mark> -

- CryptEncrypt, as the name indicates, actually encrypts data.
- CryptEncrypt ==Encrypts with the Key from CryptImportKey and the Algorithm Specified by CryptAcquireContextA==.
- Syntax -

```c++
BOOL CryptEncrypt(
  [in]      HCRYPTKEY  hKey,
  [in]      HCRYPTHASH hHash,
  [in]      BOOL       Final,
  [in]      DWORD      dwFlags,
  [in, out] BYTE       *pbData,
  [in, out] DWORD      *pdwDataLen,
  [in]      DWORD      dwBufLen
);
```

1. <mark style="background: #FFB86CA6;">hKey (1)</mark> : Handle to a key typically imported by CryptImportKey
2.  <mark style="background: #D2B3FFA6;">*pbData (5)</mark> : Pointer to the data to encrypt (overwritten with ciphertext)
3.  <mark style="background: #E632B3A6;">*pdwDataLen (6)</mark> : Pointer to size of data to encrypt
4.  <mark style="background: #07E997A6;">dwBufLen (7)</mark> : Size of buffer for encrypted data

The encrypted content may be larger than the plaintext data.

[MSDN Cryptencrypt](https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt)

## # `Anatomy of WindowsAPI in Malware` -

• CryptAcquireContext: Acquire a handle to a Cryptographic Service Provider (CSP)
• CryptImportKey: Imports embedded public key
• CryptGenRandom: Generates per-file key
• CryptEncrypt: Encrypts per-file key with embedded public key
• CreateFile (read/write): Accesses file
• SetFilePointerEx: Update file pointer to the end of the file
• WriteFile: Write the encrypted key to the end of the file
• SetFilePointerEx: Update file pointer to the beginning of the file
• ReadFile: Read contents of unencrypted file
• \<Encrypt contents of the file>
• WriteFile: Write the encrypted contents to the file

## # `How to Identify Encryption Functions` -

• <mark style="background: #FFB86CA6;">Locate Microsoft APIs</mark> : 
	• CryptoAPI functions responsible for importing, generating, and using keys
	 • APIs responsible for interacting with files for reading unencrypted data and writing encrypted content 
• <mark style="background: #D2B3FFA6;">Identify encryption constants and numerical values associated with encryption algorithms</mark> :
	• FindCrypt plugin for Ghidra 
	• FindCrypt extension for Ghidra
• Mathematical operations associated with an algorithm (e.g., ROL/ROR).

Some good BreakPoints -

• CryptoAPI functions may not be listed in the IAT, but we can set the breakpoint on library code
• Key APIs to consider include:
	• CryptAcquireContextA/CryptAcquireContextW
	• CryptImportKey
	• CryptGenRandom
	• CryptGenKey
	• CryptExportKey
	• CryptEncrypt

Note that if you attempt to set these breakpoints in x64dbg when you first load the program in a debugger, you may receive a message indicating the breakpoints are invalid. This is because the advapi.dll, which exports these APIs, may not have been loaded yet. In this case, you may need to wait until after the DLL is loaded (assuming it gets loaded at some point). One approach is to set breakpoints on LoadLibraryA, LoadLibraryW, LoadLibraryExA, and LoadLibraryExW and observe when advapi32.dll is loaded. Once this DLL is loaded, attempt to set the breakpoints discussed above.

==Advapi32.dll, which exports these APIs, must be loaded to set these breakpoints==.

