## # `What are Packers?` -

Packers are software that protects other software through obfuscation,compression,virtualization etc

Different types of Packers :

1. <mark style="background: #3D7EFFA6;">Free</mark> - 

Easiest ; created as a part of research project or simply out of interest ; very commonly used to pack less sophisticated malware.

Example :

- UPX
- nPack
- MEW
- PolyCrypter
- MPRESS
- PE Protector

2. <mark style="background: #FFB86CA6;">Malware</mark> - 

Regular ; custom packers written solely for obfuscating malware and hiding from AV ; custom to specific groups.

Example :

- WarzoneCrypter
- YakuzaCrypter
- AtillaCrypter
- AspireCrypt
- Emotet,Dridex,IFSB,Trickbot etc packer

3. <mark style="background: #D2B3FFA6;">Commercial</mark> -

Difficult ; created to protect legitimate software, typically licensed software ; occasionaly used to protect malware.

Example :

- VMProtect
- Themida
- Obsidium
- Armadillo

## # `Detecting Malwares` -

- <mark style="background: #3D7EFFA6;">Signatures</mark> -

Tools like PEStudio,PEID,YaraScan, etc. can pick up signatures and detect based on rules.Signatures range from values to byte patterns.

- <mark style="background: #FFB86CA6;">Strings</mark> -

A lack of strings (or an abundance nonsensical strings) in the binary could be an indicator the program is packed in some way.

- <mark style="background: #D2B3FFA6;">Section Names</mark> -

Packers commonly add extra sections to the binary, such as UPX. These names could be named after the packer, or be completely random.

- <mark style="background: #E632B3A6;">Raw/Virtual Sizes</mark> -

Raw section sizes signify the size of sections while not running, while Virtual section sizes are the opposite. Noticeable differences between the two could indicate the sample is packed.

- <mark style="background: #07E997A6;">Imports</mark> -

Once again, a lack of imports (or an abundance of unusual imports) in the binary could be an indicator the program Is packed.

- <mark style="background: #3D7EFFA6;">Entropy</mark> -

The entropy is determined by the frequency of recurring bytes - the higher the entropy, the lower the amount of recurring bytes - this usually indicates the data in encrypted.

## # `Unpacking` -

So how do we go about acquire the malicious code that has been packed? We conduct a processcall dumping, allowing the unpacker to load the malicious executable into memory and thenusing a tool to dump the running process into a file on disk.

Often the dumped file might be broken when we attempt to run it - probably because the entrypoint of the PE is pointing to the unpacker code, but we need to begin at the unpacked code. Usually the import address table (IAT) is also mangled, and the executable doesn't know how tolocate its resources.

Here are some tools aimed at dumping unpacked executables from memory to disk, as well as reconstructing an executable's entry point and IAT:

- Scylla
- PE Tools
- Universal Import Fixer
- Imports Fixer

One obstacle standing in our way is ASLR (address space layout randomization). This is a feature for operating systems that allows operating systems to ignore an executable's base address andrandomizes address locations. This prevents hackers from being able to determine the locationof different resources within an executable, increasing security.Below are two tools that can be used to disable ASLR for portable executables:

- CFF Explorer
- setdllcharacteristics

***Summary*** -

In summary, to begin unpacking malware, here are some important steps and things toremember:

- Disable ASLR on packed programs in order to make analysis easier.
- Allow the malicious program to unpack itself; then dump it.
- Dumped files might not be runnable because the entry point is broken.

## # `Using Debuggers for Dumping` -

Using debuggers to unpack and extract packed executables is a safer and more precise way of acquiring packed malicious code. In order to do this, we need to set a breakpoint at the end of the unpacking code in the debugger. This is usually a JMP or CALL instruction pointing to theunpacked code's Original Entry Point (OEP). You can also identify the ending of unpacked codeby looking for a location filled with lots of zeros and no instructions remaining after that.

After reaching unpacked code, in a debugger like x64dbg, we can search for newly existing strings and intermodular calls to confirm that we have found the unpacked code. In most debuggers, you can just right-click the assembly you're looking at and then search for thesethings.

We should let the malware run without any breakpoints. View the malware's memory regions with the debugger, and search for memory regions thathave the "execute" flag set - this denotes these memory regions are allowed to executeinstructions on the CPU. Navigate to that particular memory region and search for interestingstrings or API calls (intermodular calls) like we did in the previous section. This will provide youwith locations of interest within the packed code that you can set hardware breakpoints at. We want to set hardware breakpoints because those are less likely to be ignored than softwarebreakpoints upon restarting the process. After setting our hardware breakpoint, we will proceed to debug the code and run until we stopat the breakpoint. From there, we should be stopped within the unpacked code. This will allow usto analyze the unpacked code without extracting it from the process.