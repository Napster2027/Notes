## # `Self-Defending Malware` -

Malware that's attempting to evade analysis is obviously going to work to avoid being debuggedby a malware analyst. For Windows executables, here are some ==common API calls used by malware to detect if it's being debugged==:

- <mark style="background: #3D7EFFA6;">IsDebuggerPresent</mark>
- <mark style="background: #FFB86CA6;">CheckRemoteDebuggerPresent</mark>
- <mark style="background: #D2B3FFA6;">NtQueryInformationProcess</mark>
- <mark style="background: #E632B3A6;">ZwQueryInformationProcess</mark>
- <mark style="background: #07E997A6;">OutputDebugString</mark>

All of these API calls can be fooled by debuggers today, including x64/32dbg, by masking the expected response for the API calls to fool the process into assessing that it isn't being debugged. With all that said, be on the watch out for malware that ==attempts to check its ProcessExecution Block (PEB)== directly, located at `FS:[30h]`. There is a 1-bit field called BeingDebuggedthat will identify that a process is currently being debugged, and malware authors attempt tocheck this rather than using the APIs listed above.

Some malware attempts to also conduct time analysis in order to determine if its running too slowly. Here are the ==common API calls that malware uses to detect it's being ran slowly within a debugger==:

- <mark style="background: #3D7EFFA6;">GetTickCount</mark>
- <mark style="background: #FFB86CA6;">GetLocalTime</mark>
- <mark style="background: #D2B3FFA6;">GetSystemTime</mark>
- <mark style="background: #E632B3A6;">NtQuerySystemTime</mark>

Malware can also use the assembly instruction `RDTSC (Read Time-Stamp Counter)` to determine how many ticks have passed since the system booted up. This can be used to accesshardware values in order to avoid using the API calls above for time analysis.

